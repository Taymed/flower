<!DOCTYPE html>
<html>
<head>
<title>Flower Clicker</title>
<style>
  /* CSS Improvements:  More organized, using variables, and some minor tweaks */
  :root {
    --petal-width: 30px;
    --petal-height: 60px;
    --stem-width: 6px;
    --stem-height: 80px;
    --flower-size: 200px; /* Consistent flower size */
  }

  body {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    transition: background-color 0.5s ease;
    font-family: sans-serif;
    background-color: #ADD8E6; /* Default background */
    overflow-x: hidden; /* Prevent horizontal scrollbar */
    background-image: 
      radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.07) 0%, transparent 20%),
      radial-gradient(circle at 80% 60%, rgba(255, 255, 255, 0.07) 0%, transparent 20%);
  }
  
  #controls {
    display: flex;
    margin-bottom: 15px;
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
  }
  
  #muteButton {
    background: none;
    border: 2px solid #FF69B4;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5em;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0;
  }
  
  #muteButton:hover {
    background-color: rgba(255, 105, 180, 0.2);
  }

  h1 {
    background: linear-gradient(to right, #FF69B4, #FFB6C1);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-size: 3em;
    margin-bottom: 20px;
    text-align: center; /* Center the heading */
  }

  #flowerContainer {
    position: relative;
    width: var(--flower-size);
    height: var(--flower-size);
    cursor: pointer;
    display: flex;
    flex-direction: column; /* Stack stem, petals, and message vertically */
    justify-content: center;
    align-items: center;
    overflow: visible;
    transition: transform 0.1s ease-in-out; /* Add subtle click animation */
  }

  #flowerContainer:active {
    transform: scale(0.95); /* Subtle shrink on click */
  }

  .petal {
    position: absolute;
    width: var(--petal-width);
    height: var(--petal-height);
    background: linear-gradient(to bottom, #FF69B4, #FFB6C1); /* Default colors */
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    transform-origin: bottom center;
    top: calc(0px - var(--petal-height) / 2); /* Correct petal positioning */
    pointer-events: none; /* Petals shouldn't block clicks */
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    animation: glow 3s ease-in-out infinite alternate;
  }
  
  @keyframes glow {
    0% { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3)); }
    100% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.7)); }
  }

  #stem {
    position: relative; /* Make stem relative for stacking context */
    bottom: 0;
    width: var(--stem-width);
    height: var(--stem-height);
    background: linear-gradient(to bottom, #32CD32, #006400);
    box-shadow: 0 0 10px rgba(50, 205, 50, 0.5);
    border-radius: 0 0 2px 2px;
  }
  
  /* Add leaves to the stem */
  #stem::before, #stem::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 10px;
    background: linear-gradient(to right, #32CD32, #006400);
    border-radius: 50% 20% 20% 50%;
    transform-origin: left center;
  }
  
  #stem::before {
    top: 30%;
    left: 2px;
    transform: rotate(-20deg);
  }
  
  #stem::after {
    top: 60%;
    left: 2px;
    transform: rotate(-30deg) scaleY(-1);
  }


  /* Add a message when there are no petals left */
  #noPetalsMessage {
    font-size: 1.2em;
    background: linear-gradient(to right, #FF69B4, #FF8C00, #FFD700);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    display: none; /* Initially hidden */
    margin-top: 10px; /* Add some space above the message */
    text-align: center;
    animation: pulse 2s ease-in-out infinite;
    font-weight: bold;
  }
  
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  #flowerContainer.no-petals #noPetalsMessage {
    display: block; /* Show message when no petals are left */
  }

  /* Style for the falling flower emojis */
  .falling-flower {
    position: absolute;
    font-size: 2em; /* Adjust size as needed */
    pointer-events: none; /*  Don't interfere with clicks */
    user-select: none;    /*  Prevent text selection */
    animation: fall 3s linear forwards; /* Use a CSS animation */
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
    z-index: 100;
  }

  @keyframes fall {
    0% {
      opacity: 1;
      transform: translateY(0) rotate(0deg) scale(1);
    }
    50% {
      opacity: 0.8;
      transform: translateY(50vh) rotate(360deg) scale(1.2);
    }
    100% {
      opacity: 0;
      transform: translateY(100vh) rotate(720deg) scale(0.8); /* Rotate and scale as it falls */
    }
  }
  
  /* Add twinkling stars in the background */
  .star {
    position: absolute;
    background-color: white;
    border-radius: 50%;
    pointer-events: none;
    animation: twinkle 5s ease-in-out infinite; /* Default duration */
    animation-duration: var(--twinkle-duration, 5s); /* Use variable if set, with fallback */
    z-index: -1;
  }
  
  @keyframes twinkle {
    0% { opacity: 0.2; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1.2); }
    100% { opacity: 0.2; transform: scale(0.8); }
  }

</style>
</head>
<body>

<h1>Flower Clicker</h1>
<div id="controls">
  <button id="muteButton">ðŸ”Š</button>
</div>
<div id="flowerContainer">
  <div id="stem"></div>
  <div id="noPetalsMessage">Click to Grow New Flower!</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script>
  // JavaScript Improvements:  More efficient, readable, and robust

  // Define a complete set of musical notes for our melodies
  // Base octave notes (octave 3)
  const g3 = 196.00;
  const a3 = 220.00;
  const b3 = 246.94;
  const c3 = 130.81;
  
  // Middle octave (octave 4)
  const c4 = 261.63;
  const d4 = 293.66;
  const eb4 = 311.13; // Flat
  const e4 = 329.63;
  const f4 = 349.23;
  const g4 = 392.00;
  const a4 = 440.00;
  const bb4 = 466.16; // Flat
  const b4 = 493.88;
  
  // Upper octave (octave 5)
  const c5 = 523.25;
  const d5 = 587.33;
  const e5 = 659.25;
  const f5 = 698.46;
  const g5 = 783.99;
  
  // Even higher notes (octave 6) for special effects
  const c6 = 1046.50;
  
  // Silent note for rests in melodies
  const SILENCE = 0;

  // Define instrument types early with better timbre profiles
  const instruments = [
    { 
      name: 'Crystal Bell', 
      type: 'sine', 
      harmonics: [1, 0.5, 0.25, 0.125], 
      detune: 3,
      attack: 0.01,
      decay: 0.2,
      sustain: 0.7,
      release: 0.4
    },
    { 
      name: 'Soft Piano', 
      type: 'triangle', 
      harmonics: [1, 0.1, 0.05], 
      detune: 2,
      attack: 0.02,
      decay: 0.1,
      sustain: 0.5,
      release: 0.3
    },
    { 
      name: 'Harp', 
      type: 'sine', 
      harmonics: [1, 0.8, 0.4, 0.2], 
      detune: 4,
      attack: 0.005,
      decay: 0.3,
      sustain: 0.3,
      release: 0.8
    },
    { 
      name: 'Music Box', 
      type: 'sine', 
      harmonics: [1, 0, 0.3, 0, 0.15, 0, 0.075], 
      detune: 0,
      attack: 0.001,
      decay: 0.1,
      sustain: 0.2,
      release: 0.3
    },
    { 
      name: 'Soft Flute', 
      type: 'sine', 
      harmonics: [1, 0.1, 0.05], 
      detune: 5,
      attack: 0.04,
      decay: 0.05,
      sustain: 0.9,
      release: 0.1
    },
    { 
      name: 'Fairy Chimes', 
      type: 'sine', 
      harmonics: [1, 0.6, 0.3, 0.1], 
      detune: 10,
      attack: 0.001,
      decay: 0.15,
      sustain: 0.4,
      release: 0.6
    }
  ];

  // Enhanced melodic phrases with famous melodies and video game tunes
  const melodicPhrases = [
    // Original simple patterns
    [c4, e4, g4, c5],           // C major arpeggio
    [c5, g4, e4, c4],           // C major arpeggio descending
    
    // Famous melody fragments
    [e4, e4, f4, g4, g4, f4, e4, d4], // Ode to Joy (Beethoven)
    [g4, e4, e4, SILENCE, f4, d4, d4],      // Twinkle Twinkle Little Star
    [c4, d4, e4, c4, e4, c4, e4],     // FÃ¼r Elise (simplified)
    [c4, g4, g4, a4, g4, SILENCE, b4, c5],  // Somewhere Over the Rainbow
    
    // VIDEO GAME MUSIC SECTION
    
    // Super Mario Bros Theme
    [e4, e4, SILENCE, e4, SILENCE, c4, e4, SILENCE, g4],
    
    // Zelda's Lullaby (Legend of Zelda)
    [e4, g4, d4, SILENCE, e4, g4, d4],
    
    // Song of Storms (Legend of Zelda)
    [d4, f4, d5, SILENCE, d4, f4, d5],
    
    // Lost Woods / Saria's Song (Legend of Zelda)
    [f4, a4, b4, f4, a4, b4, f4, a4, b4, e5, d5, b4],
    
    // Tetris Theme (Korobeiniki)
    [e5, b4, c5, d5, c5, b4, a4, a4, c5, e5, d5, c5],
    
    // Pokemon Center Healing Theme
    [g4, c5, c5, c5, b4, c5, g4, e4],
    
    // Undertale - Megalovania Intro
    [d4, d4, d5, SILENCE, a4, SILENCE, g4, SILENCE, f4],
    
    // Sonic the Hedgehog - Green Hill Zone
    [e4, g4, c5, e5, SILENCE, d5, c5, b4],
    
    // Kirby's Dream Land Theme
    [c5, b4, a4, g4, a4, b4, c5, d5, e5],
    
    // Final Fantasy Victory Fanfare
    [c4, c4, c4, c4, SILENCE, g3, c4, e4, g4, c5],
    
    // Chrono Trigger - Peaceful Days
    [a4, c5, d5, e5, c5, d5, e5, g5, e5],
    
    // Minecraft Calm
    [c4, g4, c5, e5, g5, e5, c5, g4],
    
    // Animal Crossing Intro Bit
    [a4, e5, d5, c5, b4, a4, g4, e4, g4, a4],
    
    // Stardew Valley Theme Fragment
    [e4, g4, a4, b4, e5, b4, a4, g4, e4],
    
    // Portal - Still Alive Theme
    [e4, a4, e4, b4, e4, g4, e4, c5, b4, a4],
    
    // The Last of Us Theme
    [e4, f4, e4, a3, c4, e4, f4, g4, f4, e4],
    
    // Hollow Knight Theme
    [b4, e5, g5, f5, e5, d5, b4, SILENCE, c5, d5],
    
    // Among Us Task Complete
    [c5, e5, g5, c6, g5, c6],
    
    // Halo Theme
    [e4, g4, e4, g4, e4, e5, d5, b4, a4, b4],
    
    // Skyrim Theme
    [a3, c4, f4, g4, a4, f4, a4, c5],
    
    // Harry Potter theme fragment (not a game but fits well)
    [b4, e5, g4, f4, e5, b4, a4, f4],
    
    // Star Wars - Force Theme fragment
    [g4, c5, b4, a4, g4, c5, b4, a4, g4],
    
    // Game of Thrones theme hint
    [g4, c4, eb4, f4, g4, c4, eb4, f4],
    
    // Studio Ghibli-inspired melody (like Totoro or Spirited Away)
    [a4, c5, a4, e4, g4, e4, d4, e4, a4],
    
    // Playful music box-like melody
    [c5, a4, c5, g4, c5, e5, c5, g4, a4],
    
    // Dreamy ascending pattern
    [c4, e4, g4, c5, e5, g5, e5, c5, g4],
    
    // Fairy-like magical descent
    [e5, c5, a4, e4, g4, e4, c4, d4, e4],
    
    // Music box waltz feel
    [c4, e4, g4, c5, e4, g4, c4, e4, g4, c5, e4, g4],
    
    // Ethereal pattern
    [e5, b4, g4, e4, b4, g4, e5, b4, g4]
  ];

  const flowerContainer = document.getElementById('flowerContainer');
  const body = document.body;
  const muteButton = document.getElementById('muteButton');
  let petals = [];
  let isMuted = false;

  // Color palettes - consider storing these in a separate JSON file for easier management
  const petalColorOptions = [
    { start: '#FF69B4', end: '#FFB6C1' },
    { start: '#FFA07A', end: '#FFDAB9' },
    { start: '#9370DB', end: '#E6E6FA' },
    { start: '#87CEFA', end: '#B0E2FF' },
    { start: '#32CD32', end: '#90EE90' },
    { start: '#FF4500', end: '#FFA07A' },
    { start: '#4682B4', end: '#ADD8E6' },
    { start: '#7B68EE', end: '#DDA0DD' },
    { start: '#F0E68C', end: '#EEE8AA' }
  ];

  const rainbowColors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];

  const backgroundColors = [
    '#181848', // Deep blue night sky
    '#23395B', // Navy twilight
    '#103778', // Royal blue dusk
    '#4A2C4A', // Purple evening
    '#251A47'  // Deep purple night
  ];

  let currentColorIndex = 0;
  let petalCount = 0; // Initialize petalCount to 0
  let rainbowFlowerChance = 0.3; // Increased chance for rainbow flowers

  // Audio Context - Moved outside functions for better performance
  let audioContext;
  let currentInstrument = 0;

  // Master reverb and compressor for better overall sound
  let masterReverb;
  let masterCompressor;

  
  // Create audio context on first interaction (to avoid Chrome's autoplay policy)
  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  // Initialize stars in the background
  function createStars() {
    const totalStars = 50;
    for (let i = 0; i < totalStars; i++) {
      const star = document.createElement('div');
      star.classList.add('star');
      
      // Random size between 2 and 6 pixels
      const size = Math.random() * 4 + 2;
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      
      // Random position
      star.style.left = `${Math.random() * 100}vw`;
      star.style.top = `${Math.random() * 100}vh`;
      
      // Random twinkle duration between 2 and 7 seconds
      const duration = Math.random() * 5 + 2;
      star.style.setProperty('--twinkle-duration', `${duration}s`);
      
      // Random delay so stars don't all twinkle at once
      star.style.animationDelay = `${Math.random() * 5}s`;
      
      document.body.appendChild(star);
    }
  }
  
  // Note frequencies are defined at the top of the file

  // Function to play a single note with more control over ADSR envelope
  function playNote(frequency, startTime, duration, gainValue, attack, decay, sustainLevel, release) {
    // Return early for silence/rest notes (frequency of 0)
    if (!audioContext || frequency === 0) return; // Safety check
    
    const instrument = instruments[currentInstrument];
    
    // Create a primary oscillator for the base note
    const primaryOscillator = audioContext.createOscillator();
    primaryOscillator.type = instrument.type;
    primaryOscillator.frequency.setValueAtTime(frequency, startTime);
    
    // Slightly detune for a richer sound
    if (instrument.detune) {
      primaryOscillator.detune.setValueAtTime(instrument.detune, startTime);
    }
    
    // Main gain node for the note
    const mainGain = audioContext.createGain();
    mainGain.gain.setValueAtTime(0, startTime); // Start at zero volume
    
    // Use instrument-specific ADSR if available, or use the provided values
    const instrumentAttack = instrument.attack || attack;
    const instrumentDecay = instrument.decay || decay;
    const instrumentSustain = instrument.sustain || sustainLevel;
    const instrumentRelease = instrument.release || release;
    
    // Attack
    mainGain.gain.linearRampToValueAtTime(gainValue, startTime + instrumentAttack);
    
    // Decay & Sustain
    mainGain.gain.exponentialRampToValueAtTime(gainValue * instrumentSustain, startTime + instrumentAttack + instrumentDecay);
    
    // Release
    mainGain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration - instrumentRelease);
    
    // Connect primary oscillator to the gain node
    primaryOscillator.connect(mainGain);
    mainGain.connect(audioContext.destination);
    
    // Start the primary oscillator
    primaryOscillator.start(startTime);
    primaryOscillator.stop(startTime + duration);
    
    // Create harmonics for more complex instrument sounds
    if (instrument.harmonics && instrument.harmonics.length > 0) {
      instrument.harmonics.forEach((gain, index) => {
        if (gain > 0) {
          // Create an oscillator for each harmonic
          const harmonicOsc = audioContext.createOscillator();
          harmonicOsc.type = instrument.type;
          
          // Set frequency to a multiple of the base frequency (harmonic)
          const harmonicNumber = index + 2; // Skip the fundamental, start with 2nd harmonic
          harmonicOsc.frequency.setValueAtTime(frequency * harmonicNumber, startTime);
          
          // Create a gain node for this harmonic
          const harmonicGain = audioContext.createGain();
          harmonicGain.gain.setValueAtTime(0, startTime);
          
          // Apply envelope to the harmonic
          harmonicGain.gain.linearRampToValueAtTime(gainValue * gain, startTime + instrumentAttack);
          harmonicGain.gain.exponentialRampToValueAtTime(gainValue * gain * instrumentSustain, startTime + instrumentAttack + instrumentDecay);
          harmonicGain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration - instrumentRelease);
          
          // Connect and start the harmonic
          harmonicOsc.connect(harmonicGain);
          harmonicGain.connect(audioContext.destination);
          harmonicOsc.start(startTime);
          harmonicOsc.stop(startTime + duration);
        }
      });
    }
  }


  function playPhrase(phrase) {
    // Don't play sounds if muted
    if (isMuted) return;
    
    // Initialize audio context if it doesn't exist yet
    initAudioContext();
    
    const now = audioContext.currentTime;
    const noteDuration = 0.4; // Slightly longer notes
    const gap = 0.1;
    let time = now;
    const gainValue = 0.06; // Reduced gain for softer sound

    // ADSR Envelope parameters (Attack, Decay, Sustain Level, Release)
    const attack = 0.05;
    const decay = 0.1;
    const sustainLevel = 0.6; //Sustain level as a fraction of the peak gain
    const release = 0.2;

    phrase.forEach(frequency => {
      playNote(frequency, time, noteDuration, gainValue, attack, decay, sustainLevel, release);
      time += noteDuration + gap;
    });
  }


  function createPetal(index, isRainbow = false) {
    const petal = document.createElement('div');
    petal.classList.add('petal');
    petal.style.transform = `rotate(${index * (360 / petalCount)}deg)`;
    petal.dataset.index = index;

    if (isRainbow) {
      petal.style.background = rainbowColors[index % rainbowColors.length];
    } else {
      petal.style.setProperty('--petal-color-start', petalColorOptions[currentColorIndex].start);
      petal.style.setProperty('--petal-color-end', petalColorOptions[currentColorIndex].end);
    }

    flowerContainer.appendChild(petal);
    return petal; // Return the petal
  }


  function animatePetalFall(petal) {
    const randomX = Math.random() * 200 - 100;
    const randomRotation = Math.random() * 360;
    const fallDuration = Math.random() * 1 + 1;
    
    // Create a trail effect for the falling petal
    const trail = setInterval(() => {
      // Get current position of the petal
      const rect = petal.getBoundingClientRect();
      if (rect.top < window.innerHeight) { // Only create trail if petal is still visible
        // Create a small particle at the petal's current position
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = '5px';
        particle.style.height = '5px';
        particle.style.borderRadius = '50%';
        
        // Get background color safely (fallback to pink if variable not set)
        let bgColor = "#FF69B4"; // Default color
        try {
          const computedStyle = getComputedStyle(petal);
          const varColor = computedStyle.getPropertyValue('--petal-color-start');
          if (varColor && varColor.trim() !== '') {
            bgColor = varColor;
          }
        } catch (e) {
          // Use default color if there's an error
        }
        
        particle.style.backgroundColor = bgColor;
        particle.style.left = `${rect.left + rect.width/2}px`;
        particle.style.top = `${rect.top + rect.height/2}px`;
        particle.style.opacity = '0.7';
        particle.style.zIndex = '90';
        particle.style.pointerEvents = 'none';
        
        document.body.appendChild(particle);
        
        // Animate and remove the trail particle
        gsap.to(particle, {
          opacity: 0,
          scale: 0.5,
          duration: 0.8,
          onComplete: () => particle.remove()
        });
      }
    }, 100); // Create a trail particle every 100ms

    // Play a random phrase from the melodicPhrases array - we'll define this later
    // Save this for when melodicPhrases is defined
    const playRandomPhrase = () => {
      if (typeof melodicPhrases !== 'undefined' && melodicPhrases.length > 0) {
        const randomIndex = Math.floor(Math.random() * melodicPhrases.length);
        playPhrase(melodicPhrases[randomIndex]);
      }
    };
    
    // Schedule this to run after everything is defined
    setTimeout(playRandomPhrase, 0);

    gsap.to(petal, {
      y: 200,
      x: randomX,
      rotation: randomRotation,
      opacity: 0,
      duration: fallDuration,
      ease: "power2.inOut",
      onComplete: () => {
        clearInterval(trail); // Stop creating trail particles
        petal.remove();
        createFallingFlowerEmoji(); // Create emoji after petal falls
        
        // Get the final position more safely
        let burstX = 0;
        let burstY = 200;
        
        // Try to extract transform values, but use defaults if it fails
        try {
          const transform = petal.style.transform || '';
          const xMatch = transform.match(/translateX\(([^)]+)\)/);
          const yMatch = transform.match(/translateY\(([^)]+)\)/);
          
          if (xMatch && xMatch[1]) burstX = parseInt(xMatch[1], 10) || 0;
          if (yMatch && yMatch[1]) burstY = parseInt(yMatch[1], 10) || 200;
        } catch (e) {
          // Use defaults if parsing fails
        }
        
        createSparkles(window.innerWidth/2 + burstX, window.innerHeight/2 + burstY/2);
      }
    });
  }

    function createFallingFlowerEmoji() {
        const emojis = ['ðŸŒ¸', 'ðŸŒ¼', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ·', 'ðŸŒ¹', 'âœ¨', 'ðŸ’®'];
        const emoji = document.createElement('div');
        emoji.classList.add('falling-flower');
        emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];

        // Position the emoji randomly at the top of the screen
        emoji.style.left = `${Math.random() * 100}vw`;
        emoji.style.top = '0'; // Start at the top
        
        // Random size for variety
        const size = Math.random() * 1.5 + 1.5; // Between 1.5 and 3em
        emoji.style.fontSize = `${size}em`;
        
        // Random color tinting
        const hue = Math.floor(Math.random() * 360);
        emoji.style.filter = `drop-shadow(0 0 10px rgba(255, 255, 255, 0.7)) hue-rotate(${hue}deg)`;
        
        document.body.appendChild(emoji);

        // Create a few sparkling particles around the emoji
        if (Math.random() > 0.5) {
            setTimeout(() => {
                try {
                    const leftPos = parseFloat(emoji.style.left) || 0;
                    const topPos = emoji.offsetTop + 50 || 50;
                    createSparkles(leftPos, topPos);
                } catch (e) {
                    // If parsing fails, use default values
                    createSparkles(window.innerWidth/2, 50);
                }
            }, Math.random() * 1000 + 500);
        }

        // Remove the emoji after the animation completes
        emoji.addEventListener('animationend', () => {
            emoji.remove();
        });
    }
    
    function createSparkles(x, y) {
        const sparkleCount = Math.floor(Math.random() * 5) + 3;
        for (let i = 0; i < sparkleCount; i++) {
            const sparkle = document.createElement('div');
            sparkle.textContent = 'âœ¨';
            sparkle.style.position = 'absolute';
            sparkle.style.left = `${x + (Math.random() * 40) - 20}px`;
            sparkle.style.top = `${y + (Math.random() * 40) - 20}px`;
            sparkle.style.fontSize = '0.8em';
            sparkle.style.opacity = '0';
            sparkle.style.zIndex = '100';
            sparkle.style.pointerEvents = 'none';
            
            document.body.appendChild(sparkle);
            
            // Create little burst animation with GSAP
            gsap.to(sparkle, {
                opacity: 1,
                duration: 0.2,
                onComplete: () => {
                    gsap.to(sparkle, {
                        opacity: 0,
                        duration: 0.5,
                        delay: 0.3,
                        scale: 0.5,
                        onComplete: () => {
                            sparkle.remove();
                        }
                    });
                }
            });
        }
    }

  function setBackgroundColor() {
    // Set the new background color with a smooth transition
    const newColor = backgroundColors[currentColorIndex];
    
    // Create a radial gradient for a more dynamic and magical background
    body.style.background = `radial-gradient(ellipse at center, ${newColor} 0%, ${adjustColor(newColor, -30)} 100%)`;
    
    // Update the color index for next time
    currentColorIndex = (currentColorIndex + 1) % backgroundColors.length;
  }
  
  // Helper function to darken or lighten a color
  function adjustColor(color, amount) {
    // Parse the hex color to RGB
    const hex = color.replace('#', '');
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);
    
    // Adjust the color
    r = Math.max(0, Math.min(255, r + amount));
    g = Math.max(0, Math.min(255, g + amount));
    b = Math.max(0, Math.min(255, b + amount));
    
    // Convert back to hex
    return `#${(r.toString(16).padStart(2, '0'))}${(g.toString(16).padStart(2, '0'))}${(b.toString(16).padStart(2, '0'))}`;
  }

  // Function to play all instruments at once (for rainbow flowers)
  function playRainbowChord() {
    if (isMuted || !audioContext) return;
    
    // Store the original instrument
    const originalInstrument = currentInstrument;
    
    // Create a fancy toast for rainbow flower
    const rainbowToast = document.createElement('div');
    rainbowToast.textContent = 'ðŸŒˆ RAINBOW FLOWER ORCHESTRA! ðŸŽµ';
    rainbowToast.style.position = 'absolute';
    rainbowToast.style.top = '50%';
    rainbowToast.style.left = '50%';
    rainbowToast.style.transform = 'translate(-50%, -50%)';
    rainbowToast.style.background = 'linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)';
    rainbowToast.style.color = 'white';
    rainbowToast.style.padding = '15px 25px';
    rainbowToast.style.borderRadius = '20px';
    rainbowToast.style.fontSize = '18px';
    rainbowToast.style.fontWeight = 'bold';
    rainbowToast.style.opacity = '0';
    rainbowToast.style.transition = 'opacity 0.5s ease';
    rainbowToast.style.zIndex = '2000';
    rainbowToast.style.textShadow = '0 0 5px black';
    rainbowToast.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.7)';
    
    document.body.appendChild(rainbowToast);
    
    // Fade in, then fade out
    setTimeout(() => {
      rainbowToast.style.opacity = '1';
      setTimeout(() => {
        rainbowToast.style.opacity = '0';
        setTimeout(() => {
          rainbowToast.remove();
        }, 1000);
      }, 3000);
    }, 100);
    
    // Get the current time from the audio context
    const now = audioContext.currentTime;
    
    // Notes for a C major chord in different octaves
    const notes = [c4, e4, g4, c5];
    
    // Time spacing between instrument entries
    const entryDelay = 0.2;
    
    // Total chord duration
    const chordDuration = 2.5;
    
    // Play each instrument with a staggered entry
    instruments.forEach((instrument, i) => {
      // Set the current instrument temporarily
      currentInstrument = i;
      
      // Play notes with this instrument with a staggered entry
      notes.forEach((note, j) => {
        // Delay each instrument's entry
        const startTime = now + (i * entryDelay);
        
        // Adjust volume based on number of instruments
        const adjustedVolume = 0.03 / Math.sqrt(instruments.length);
        
        // Create random sparkles for each note
        setTimeout(() => {
          createSparkles(
            window.innerWidth * Math.random(), 
            window.innerHeight * Math.random()
          );
        }, i * entryDelay * 1000 + j * 100);
        
        // Play the note
        playNote(
          note,                  // frequency
          startTime,             // start time
          chordDuration,         // duration
          adjustedVolume,        // volume (adjusted down for many instruments)
          0.05,                  // attack
          0.1,                   // decay
          0.6,                   // sustain
          0.8                    // release
        );
      });
    });
    
    // Return to the original instrument
    currentInstrument = originalInstrument;
  }

  function resetFlower() {
    // Clear existing petals efficiently
    petals.forEach(petal => petal.remove());
    petals = [];

    petalCount = Math.floor(Math.random() * 10) + 5;
    currentColorIndex = Math.floor(Math.random() * petalColorOptions.length);
    setBackgroundColor();
    
    // Change to a new instrument for this flower
    currentInstrument = (currentInstrument + 1) % instruments.length;
    
    // Generate a rainbow flower randomly
    let isRainbowFlower = Math.random() < rainbowFlowerChance;
    
    // Create new petals and store them in the petals array
    for (let i = 0; i < petalCount; i++) {
      const petal = createPetal(i, isRainbowFlower);
      petals.push(petal);
    }

    // Remove the 'no-petals' class
    flowerContainer.classList.remove('no-petals');
    
    // Initialize audio context if needed
    if (!isMuted) {
      initAudioContext();
    }
    
    // For rainbow flowers, play all instruments at once!
    if (isRainbowFlower && !isMuted) {
      playRainbowChord();
    } 
    // For regular flowers, show the instrument name and play a chord
    else if (!isMuted) {
      // Display the current instrument name
      const instrumentName = instruments[currentInstrument].name;
      const instrumentToast = document.createElement('div');
      instrumentToast.textContent = `ðŸŽµ ${instrumentName}`;
      instrumentToast.style.position = 'absolute';
      instrumentToast.style.bottom = '20px';
      instrumentToast.style.left = '50%';
      instrumentToast.style.transform = 'translateX(-50%)';
      instrumentToast.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      instrumentToast.style.color = 'white';
      instrumentToast.style.padding = '8px 15px';
      instrumentToast.style.borderRadius = '20px';
      instrumentToast.style.fontSize = '14px';
      instrumentToast.style.opacity = '0';
      instrumentToast.style.transition = 'opacity 0.3s ease';
      instrumentToast.style.zIndex = '1000';
      
      document.body.appendChild(instrumentToast);
      
      // Fade in, then fade out
      setTimeout(() => {
        instrumentToast.style.opacity = '1';
        setTimeout(() => {
          instrumentToast.style.opacity = '0';
          setTimeout(() => {
            instrumentToast.remove();
          }, 500);
        }, 2000);
      }, 100);
      
      // Play a chord with the new instrument to introduce it
      const now = audioContext.currentTime;
      [c4, e4, g4].forEach((note, index) => {
        playNote(note, now, 1.5, 0.04, 0.05, 0.1, 0.6, 0.5);
      });
    }
  }


  function handleFlowerClick() {
    // Initialize audio context on first interaction
    initAudioContext();
    
    if (petals.length > 0) {
      const randomIndex = Math.floor(Math.random() * petals.length);
      const petalToFall = petals[randomIndex];
      animatePetalFall(petalToFall);
      petals.splice(randomIndex, 1); // Remove petal from array


      if (petals.length === 0) {
        flowerContainer.classList.add('no-petals'); // Add class when no petals
      }
    } else {
      resetFlower();
    }
  }


  flowerContainer.addEventListener('click', handleFlowerClick);
  
  // Mute button functionality
  function toggleMute() {
    isMuted = !isMuted;
    
    // Update button text based on mute state
    muteButton.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
    
    // Add visual indicator of mute state
    if (isMuted) {
      muteButton.style.borderColor = '#888';
      muteButton.style.color = '#888';
    } else {
      muteButton.style.borderColor = '#FF69B4';
      muteButton.style.color = '#000';
      
      // Initialize and resume audio context if unmuting
      initAudioContext();
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      // Show the current instrument when unmuting
      const instrumentName = instruments[currentInstrument].name;
      const instrumentToast = document.createElement('div');
      instrumentToast.textContent = `ðŸŽµ Current: ${instrumentName}`;
      instrumentToast.style.position = 'absolute';
      instrumentToast.style.bottom = '20px';
      instrumentToast.style.left = '50%';
      instrumentToast.style.transform = 'translateX(-50%)';
      instrumentToast.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      instrumentToast.style.color = 'white';
      instrumentToast.style.padding = '8px 15px';
      instrumentToast.style.borderRadius = '20px';
      instrumentToast.style.fontSize = '14px';
      instrumentToast.style.opacity = '0';
      instrumentToast.style.transition = 'opacity 0.3s ease';
      instrumentToast.style.zIndex = '1000';
      
      document.body.appendChild(instrumentToast);
      
      // Fade in, then fade out
      setTimeout(() => {
        instrumentToast.style.opacity = '1';
        setTimeout(() => {
          instrumentToast.style.opacity = '0';
          setTimeout(() => {
            instrumentToast.remove();
          }, 500);
        }, 2000);
      }, 100);
    }
    
    // Play a quick sound feedback when unmuting (but not when initially muting)
    if (!isMuted && audioContext) {
      const now = audioContext.currentTime;
      playNote(c4, now, 0.1, 0.03, 0.01, 0.05, 0.5, 0.05);
    }
  }
  
  muteButton.addEventListener('click', toggleMute);

  // Create background stars
  createStars();
  
  // Initial flower creation
  resetFlower();
  
  // Add a welcome sound on page load (will only play after first interaction due to browser policies)
  window.addEventListener('click', function initialClick() {
    if (!isMuted) {
      initAudioContext();
      if (audioContext) {
        // Just for fun, force a rainbow flower orchestra on first load
        playRainbowChord();
      }
    }
    
    // Add some initial sparkle effects
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        createSparkles(Math.random() * window.innerWidth, Math.random() * window.innerHeight);
      }, i * 200);
    }
    
    // Create a few falling flowers for visual impact
    for (let i = 0; i < 8; i++) {
      setTimeout(() => {
        createFallingFlowerEmoji();
      }, i * 150);
    }
    
    // Welcome message
    setTimeout(() => {
      const welcomeMsg = document.createElement('div');
      welcomeMsg.textContent = 'âœ¨ Click the flower to play! âœ¨';
      welcomeMsg.style.position = 'absolute';
      welcomeMsg.style.bottom = '40px';
      welcomeMsg.style.left = '50%';
      welcomeMsg.style.transform = 'translateX(-50%)';
      welcomeMsg.style.background = 'rgba(0, 0, 0, 0.7)';
      welcomeMsg.style.color = 'white';
      welcomeMsg.style.padding = '10px 20px';
      welcomeMsg.style.borderRadius = '20px';
      welcomeMsg.style.fontSize = '16px';
      welcomeMsg.style.opacity = '0';
      welcomeMsg.style.transition = 'opacity 0.5s ease';
      welcomeMsg.style.zIndex = '2000';
      
      document.body.appendChild(welcomeMsg);
      
      // Fade in, then fade out
      setTimeout(() => {
        welcomeMsg.style.opacity = '1';
        setTimeout(() => {
          welcomeMsg.style.opacity = '0';
          setTimeout(() => {
            welcomeMsg.remove();
          }, 1000);
        }, 3000);
      }, 500);
    }, 1000);
    
    // Remove the event listener after first click
    window.removeEventListener('click', initialClick);
  }, {once: true});
  // Audio instrument definitions already moved to the top of the file

// Master effects already defined at the top of the file

// Enhanced audio context initialization
function initAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: 'interactive',
      sampleRate: 48000
    });
    
    // Create master effects
    setupMasterEffects();
  }
}

// Set up master effects chain
function setupMasterEffects() {
  // Create compressor to even out volume and prevent clipping
  masterCompressor = audioContext.createDynamicsCompressor();
  masterCompressor.threshold.value = -24;
  masterCompressor.knee.value = 30;
  masterCompressor.ratio.value = 12;
  masterCompressor.attack.value = 0.003;
  masterCompressor.release.value = 0.25;
  masterCompressor.connect(audioContext.destination);
  
  // Create convolver for reverb effect
  masterReverb = audioContext.createConvolver();
  
  // Create custom impulse response for reverb
  const reverbLength = 2; // 2 seconds reverb
  const sampleRate = audioContext.sampleRate;
  const impulseLength = sampleRate * reverbLength;
  const impulseResponse = audioContext.createBuffer(2, impulseLength, sampleRate);
  
  for (let channel = 0; channel < 2; channel++) {
    const channelData = impulseResponse.getChannelData(channel);
    for (let i = 0; i < impulseLength; i++) {
      // Exponential decay for natural reverb sound
      channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, 1.5);
    }
  }
  
  masterReverb.buffer = impulseResponse;
  
  // Create gain node for reverb mix (wet/dry)
  const reverbGain = audioContext.createGain();
  reverbGain.gain.value = 0.2; // Subtle reverb
  
  // Connect reverb to compressor
  masterReverb.connect(reverbGain);
  reverbGain.connect(masterCompressor);
}

// Apply frequency modulation for more expressive sound
function applyFrequencyModulation(oscillator, baseFrequency, startTime, duration) {
  // Create a very subtle vibrato effect
  const vibratoAmount = baseFrequency * 0.005; // 0.5% vibrato
  const vibratoSpeed = 5; // 5 Hz
  
  // Apply vibrato using the frequency parameter
  for (let i = 0; i < duration * 10; i++) {
    const time = startTime + (i / 10);
    const vibratoValue = baseFrequency + Math.sin(2 * Math.PI * vibratoSpeed * (time - startTime)) * vibratoAmount;
    oscillator.frequency.linearRampToValueAtTime(vibratoValue, time);
  }
}

// Apply ADSR envelope with smoother curves
function applyEnvelope(gainParam, startTime, duration, peakValue, attack, decay, sustainLevel, release) {
  // Start at zero
  gainParam.setValueAtTime(0, startTime);
  
  // Attack phase - exponential curve for more natural sound
  gainParam.setTargetAtTime(peakValue, startTime, attack / 3);
  
  // Decay phase - exponential descent to sustain level
  const decayStartTime = startTime + attack;
  gainParam.setTargetAtTime(peakValue * sustainLevel, decayStartTime, decay / 3);
  
  // Release phase - exponential fade out
  const releaseStartTime = startTime + duration - release;
  gainParam.setTargetAtTime(0.0001, releaseStartTime, release / 3);
}

// Enhanced note playing function
function playNote(frequency, startTime, duration, gainValue, attack, decay, sustainLevel, release) {
  if (!audioContext) return;
  
  const instrument = instruments[currentInstrument];
  
  // Use better envelope parameters from the instrument definition
  const instrumentAttack = instrument.attack || attack;
  const instrumentDecay = instrument.decay || decay;
  const instrumentSustain = instrument.sustain || sustainLevel;
  const instrumentRelease = instrument.release || release;
  
  // Create oscillator for the main note
  const primaryOscillator = audioContext.createOscillator();
  primaryOscillator.type = instrument.type;
  primaryOscillator.frequency.setValueAtTime(frequency, startTime);
  
  // Apply slight detune for more organic sound
  if (instrument.detune) {
    primaryOscillator.detune.setValueAtTime(instrument.detune, startTime);
  }
  
  // Apply slight frequency modulation for more liveliness
  applyFrequencyModulation(primaryOscillator, frequency, startTime, duration);
  
  // Create a new gain node for the note's volume
  const mainGain = audioContext.createGain();
  mainGain.gain.setValueAtTime(0, startTime);
  
  // Apply envelope to the gain node
  applyEnvelope(mainGain.gain, startTime, duration, gainValue, 
                instrumentAttack, instrumentDecay, instrumentSustain, instrumentRelease);

  // Apply filtering for a warmer tone
  const filter = audioContext.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 8000; // Adjust to taste
  filter.Q.value = 0.5;
  
  // Connect the oscillator to the filter and gain
  primaryOscillator.connect(filter);
  filter.connect(mainGain);
  
  // Connect to both dry and wet (reverb) paths
  mainGain.connect(masterCompressor); // Dry path
  mainGain.connect(masterReverb);     // Wet path
  
  // Start the oscillator
  primaryOscillator.start(startTime);
  primaryOscillator.stop(startTime + duration + instrumentRelease);
  
  // Create harmonics for more complex instrument sounds
  if (instrument.harmonics && instrument.harmonics.length > 0) {
    instrument.harmonics.forEach((gain, index) => {
      if (gain > 0) {
        // Create an oscillator for each harmonic
        const harmonicOsc = audioContext.createOscillator();
        harmonicOsc.type = instrument.type;
        
        // Set frequency to a multiple of the base frequency
        const harmonicNumber = index + 2;
        harmonicOsc.frequency.setValueAtTime(frequency * harmonicNumber, startTime);
        
        // Apply gentle detune to each harmonic for chorus effect
        const harmonicDetune = instrument.detune ? instrument.detune * (index + 1) / 2 : 0;
        harmonicOsc.detune.setValueAtTime(harmonicDetune, startTime);
        
        // Create a gain node for this harmonic
        const harmonicGain = audioContext.createGain();
        harmonicGain.gain.setValueAtTime(0, startTime);
        
        // Apply envelope to the harmonic
        applyEnvelope(harmonicGain.gain, startTime, duration, gainValue * gain, 
                    instrumentAttack, instrumentDecay, instrumentSustain, instrumentRelease);
        
        // Connect the harmonic through the filter chain
        harmonicOsc.connect(harmonicGain);
        harmonicGain.connect(filter);
        
        // Start the harmonic oscillator
        harmonicOsc.start(startTime);
        harmonicOsc.stop(startTime + duration + instrumentRelease);
      }
    });
  }
}

// Improved function to play a melodic phrase
function playPhrase(phrase) {
  if (isMuted) return;
  
  initAudioContext();
  
  const now = audioContext.currentTime;
  const noteDuration = 0.35; // Shorter notes for better clarity
  const gap = 0.05;         // Shorter gaps between notes
  let time = now;
  
  // Reduced gain for better mixing
  const gainValue = 0.05;
  
  phrase.forEach(frequency => {
    playNote(frequency, time, noteDuration, gainValue, 
             0.03, 0.1, 0.6, 0.2);
    time += noteDuration + gap;
  });
}

// Improved Rainbow Chord function
function playRainbowChord() {
  if (isMuted || !audioContext) return;
  
  const originalInstrument = currentInstrument;
  const now = audioContext.currentTime;
  
  // Create a rich chord with better spacing
  const notes = [
    c4, 
    e4, 
    g4, 
    c5, 
    e5
  ];
  
  // Slightly longer chord duration for better effect
  const chordDuration = 3;
  const entryDelay = 0.15;
  
  // Arpeggiate the chord for a more magical effect
  instruments.forEach((instrument, i) => {
    currentInstrument = i;
    
    notes.forEach((note, j) => {
      // Stagger the notes for a harp-like effect
      const startTime = now + (i * entryDelay) + (j * 0.1);
      
      // Adjust volume for better mix
      const adjustedVolume = 0.025 / Math.sqrt(instruments.length);
      
      playNote(
        note,
        startTime,
        chordDuration - (j * 0.1),  // Slightly shorter duration for higher notes
        adjustedVolume,
        0.03,
        0.15,
        0.6,
        0.8
      );
    });
  });
  
  // Return to the original instrument
  currentInstrument = originalInstrument;
}

// Melodic phrases defined at the top of the file

// Notes defined at the top of the file
</script>

</body>
</html>

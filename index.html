<!DOCTYPE html>
<html>
<head>
<title>Flower Clicker</title>
<style>
  /* CSS Improvements:  More organized, using variables, and some minor tweaks */
  :root {
    --petal-width: 30px;
    --petal-height: 60px;
    --stem-width: 6px;
    --stem-height: 80px;
    --flower-size: 200px; /* Consistent flower size */
  }

  body {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    transition: background-color 0.5s ease;
    font-family: sans-serif;
    background-color: #ADD8E6; /* Default background */
    overflow-x: hidden; /* Prevent horizontal scrollbar */
    background-image: 
      radial-gradient(circle at 10% 20%, rgba(255, 255, 255, 0.07) 0%, transparent 20%),
      radial-gradient(circle at 80% 60%, rgba(255, 255, 255, 0.07) 0%, transparent 20%);
  }
  
  #controls {
    display: flex;
    margin-bottom: 15px;
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
  }
  
  #muteButton {
    background: none;
    border: 2px solid #FF69B4;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5em;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0;
  }
  
  #muteButton:hover {
    background-color: rgba(255, 105, 180, 0.2);
  }

  h1 {
    background: linear-gradient(to right, #FF69B4, #FFB6C1);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-size: 3em;
    margin-bottom: 20px;
    text-align: center; /* Center the heading */
  }

  #flowerContainer {
    position: relative;
    width: var(--flower-size);
    height: var(--flower-size);
    cursor: pointer;
    display: flex;
    flex-direction: column; /* Stack stem, petals, and message vertically */
    justify-content: center;
    align-items: center;
    overflow: visible;
    transition: transform 0.1s ease-in-out; /* Add subtle click animation */
  }

  #flowerContainer:active {
    transform: scale(0.95); /* Subtle shrink on click */
  }

  .petal {
    position: absolute;
    width: var(--petal-width);
    height: var(--petal-height);
    background: linear-gradient(to bottom, var(--petal-color-start), var(--petal-color-end));
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    transform-origin: bottom center;
    top: calc(0px - var(--petal-height) / 2); /* Correct petal positioning */
    pointer-events: none; /* Petals shouldn't block clicks */
    box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    animation: glow 3s ease-in-out infinite alternate;
  }
  
  @keyframes glow {
    0% { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.3)); }
    100% { filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.7)); }
  }

  #stem {
    position: relative; /* Make stem relative for stacking context */
    bottom: 0;
    width: var(--stem-width);
    height: var(--stem-height);
    background: linear-gradient(to bottom, #32CD32, #006400);
    box-shadow: 0 0 10px rgba(50, 205, 50, 0.5);
    border-radius: 0 0 2px 2px;
  }
  
  /* Add leaves to the stem */
  #stem::before, #stem::after {
    content: '';
    position: absolute;
    width: 20px;
    height: 10px;
    background: linear-gradient(to right, #32CD32, #006400);
    border-radius: 50% 20% 20% 50%;
    transform-origin: left center;
  }
  
  #stem::before {
    top: 30%;
    left: 2px;
    transform: rotate(-20deg);
  }
  
  #stem::after {
    top: 60%;
    left: 2px;
    transform: rotate(-30deg) scaleY(-1);
  }


  /* Add a message when there are no petals left */
  #noPetalsMessage {
    font-size: 1.2em;
    background: linear-gradient(to right, #FF69B4, #FF8C00, #FFD700);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
    display: none; /* Initially hidden */
    margin-top: 10px; /* Add some space above the message */
    text-align: center;
    animation: pulse 2s ease-in-out infinite;
    font-weight: bold;
  }
  
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }

  #flowerContainer.no-petals #noPetalsMessage {
    display: block; /* Show message when no petals are left */
  }

  /* Style for the falling flower emojis */
  .falling-flower {
    position: absolute;
    font-size: 2em; /* Adjust size as needed */
    pointer-events: none; /*  Don't interfere with clicks */
    user-select: none;    /*  Prevent text selection */
    animation: fall 3s linear forwards; /* Use a CSS animation */
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
    z-index: 100;
  }

  @keyframes fall {
    0% {
      opacity: 1;
      transform: translateY(0) rotate(0deg) scale(1);
    }
    50% {
      opacity: 0.8;
      transform: translateY(50vh) rotate(360deg) scale(1.2);
    }
    100% {
      opacity: 0;
      transform: translateY(100vh) rotate(720deg) scale(0.8); /* Rotate and scale as it falls */
    }
  }
  
  /* Add twinkling stars in the background */
  .star {
    position: absolute;
    background-color: white;
    border-radius: 50%;
    pointer-events: none;
    animation: twinkle var(--twinkle-duration) ease-in-out infinite;
    z-index: -1;
  }
  
  @keyframes twinkle {
    0% { opacity: 0.2; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1.2); }
    100% { opacity: 0.2; transform: scale(0.8); }
  }

</style>
</head>
<body>

<h1>Flower Clicker</h1>
<div id="controls">
  <button id="muteButton">ðŸ”Š</button>
</div>
<div id="flowerContainer">
  <div id="stem"></div>
  <div id="noPetalsMessage">Click to Grow New Flower!</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script>
  // JavaScript Improvements:  More efficient, readable, and robust

  const flowerContainer = document.getElementById('flowerContainer');
  const body = document.body;
  const muteButton = document.getElementById('muteButton');
  let petals = [];
  let isMuted = false;

  // Color palettes - consider storing these in a separate JSON file for easier management
  const petalColorOptions = [
    { start: '#FF69B4', end: '#FFB6C1' },
    { start: '#FFA07A', end: '#FFDAB9' },
    { start: '#9370DB', end: '#E6E6FA' },
    { start: '#87CEFA', end: '#B0E2FF' },
    { start: '#32CD32', end: '#90EE90' },
    { start: '#FF4500', end: '#FFA07A' },
    { start: '#4682B4', end: '#ADD8E6' },
    { start: '#7B68EE', end: '#DDA0DD' },
    { start: '#F0E68C', end: '#EEE8AA' }
  ];

  const rainbowColors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];

  const backgroundColors = [
    '#181848', // Deep blue night sky
    '#23395B', // Navy twilight
    '#103778', // Royal blue dusk
    '#4A2C4A', // Purple evening
    '#251A47'  // Deep purple night
  ];

  let currentColorIndex = 0;
  let petalCount = 0; // Initialize petalCount to 0
  let rainbowFlowerChance = 0.3; // Increased chance for rainbow flowers

  // Audio Context - Moved outside functions for better performance
  let audioContext;
  let currentInstrument = 0;
  
  // Define different instrument types
  const instruments = [
    { name: 'Sine Wave', type: 'sine', harmonics: [], detune: 0 },
    { name: 'Music Box', type: 'sine', harmonics: [1, 0.6, 0.2], detune: 5 },
    { name: 'Bell', type: 'sine', harmonics: [1, 0.3, 0.1, 0.05], detune: 10 },
    { name: 'Flute', type: 'sine', harmonics: [1, 0.1], detune: 2 },
    { name: 'Xylophone', type: 'sine', harmonics: [1], detune: 0, attack: 0.01, decay: 0.2, release: 0.3 },
    { name: 'Choir', type: 'sine', harmonics: [1, 0.5, 0.3, 0.2, 0.1], detune: 8 }
  ];
  
  // Create audio context on first interaction (to avoid Chrome's autoplay policy)
  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  // Initialize stars in the background
  function createStars() {
    const totalStars = 50;
    for (let i = 0; i < totalStars; i++) {
      const star = document.createElement('div');
      star.classList.add('star');
      
      // Random size between 2 and 6 pixels
      const size = Math.random() * 4 + 2;
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      
      // Random position
      star.style.left = `${Math.random() * 100}vw`;
      star.style.top = `${Math.random() * 100}vh`;
      
      // Random twinkle duration between 2 and 7 seconds
      const duration = Math.random() * 5 + 2;
      star.style.setProperty('--twinkle-duration', `${duration}s`);
      
      // Random delay so stars don't all twinkle at once
      star.style.animationDelay = `${Math.random() * 5}s`;
      
      document.body.appendChild(star);
    }
  }
  
  // Frequencies for C Major Pentatonic Scale (C-D-E-G-A)
  const c4 = 261.63;
  const d4 = 293.66;
  const e4 = 329.63;
  const g4 = 392.00;
  const a4 = 440.00;
  const c5 = 523.25;
  const eb4 = 311.13; // Eb4 (from C minor pentatonic - for modal mixture)
  const bb4 = 466.16; // Bb4 (from C minor pentatonic - for modal mixture)

  // Melodic Phrases based on C Major Pentatonic with Rhythmic Variation
  const melodicPhrases = [
    [c4, d4, e4, g4],       // Phrase 1: C - D - E - G
    [e4, d4, c4, a4],       // Phrase 2: E - D - C - A
    [g4, a4, c5, e4],       // Phrase 3: G - A - C (octave) - E
    [a4, g4, e4, d4],       // Phrase 4: A - G - E - D
    [c4, e4, g4, c5],       // Phrase 5: C - E - G - C (octave)
    [d4, c4, a4, g4],       // Phrase 6: D - C - A - G
    [e4, g4, a4, e4],       // Phrase 7: E - G - A - E
    [g4, e4, d4, c4],       // Phrase 8: G - E - D - C
    [c4, eb4, g4, bb4],     // Phrase 9: C - Eb - G - Bb (Minor Pentatonic - Use Sparingly!)
    [e4, c4, g4],           // Phrase 10: E - C - G (Simple Triad)
    [a4, e4, c4],           // Phrase 11: A - E - C (Simple Triad)
    [g4, d4, c4],           // Phrase 12: G - D - C
    [c5, a4, g4, e4],       // Phrase 13: C5 - A - G - E
    [d4, g4, c5]            // Phrase 14: D - G - C5
  ];

  // Function to play a single note with more control over ADSR envelope
  function playNote(frequency, startTime, duration, gainValue, attack, decay, sustainLevel, release) {
    if (!audioContext) return; // Safety check
    
    const instrument = instruments[currentInstrument];
    
    // Create a primary oscillator for the base note
    const primaryOscillator = audioContext.createOscillator();
    primaryOscillator.type = instrument.type;
    primaryOscillator.frequency.setValueAtTime(frequency, startTime);
    
    // Slightly detune for a richer sound
    if (instrument.detune) {
      primaryOscillator.detune.setValueAtTime(instrument.detune, startTime);
    }
    
    // Main gain node for the note
    const mainGain = audioContext.createGain();
    mainGain.gain.setValueAtTime(0, startTime); // Start at zero volume
    
    // Use instrument-specific ADSR if available, or use the provided values
    const instrumentAttack = instrument.attack || attack;
    const instrumentDecay = instrument.decay || decay;
    const instrumentSustain = instrument.sustain || sustainLevel;
    const instrumentRelease = instrument.release || release;
    
    // Attack
    mainGain.gain.linearRampToValueAtTime(gainValue, startTime + instrumentAttack);
    
    // Decay & Sustain
    mainGain.gain.exponentialRampToValueAtTime(gainValue * instrumentSustain, startTime + instrumentAttack + instrumentDecay);
    
    // Release
    mainGain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration - instrumentRelease);
    
    // Connect primary oscillator to the gain node
    primaryOscillator.connect(mainGain);
    mainGain.connect(audioContext.destination);
    
    // Start the primary oscillator
    primaryOscillator.start(startTime);
    primaryOscillator.stop(startTime + duration);
    
    // Create harmonics for more complex instrument sounds
    if (instrument.harmonics && instrument.harmonics.length > 0) {
      instrument.harmonics.forEach((gain, index) => {
        if (gain > 0) {
          // Create an oscillator for each harmonic
          const harmonicOsc = audioContext.createOscillator();
          harmonicOsc.type = instrument.type;
          
          // Set frequency to a multiple of the base frequency (harmonic)
          const harmonicNumber = index + 2; // Skip the fundamental, start with 2nd harmonic
          harmonicOsc.frequency.setValueAtTime(frequency * harmonicNumber, startTime);
          
          // Create a gain node for this harmonic
          const harmonicGain = audioContext.createGain();
          harmonicGain.gain.setValueAtTime(0, startTime);
          
          // Apply envelope to the harmonic
          harmonicGain.gain.linearRampToValueAtTime(gainValue * gain, startTime + instrumentAttack);
          harmonicGain.gain.exponentialRampToValueAtTime(gainValue * gain * instrumentSustain, startTime + instrumentAttack + instrumentDecay);
          harmonicGain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration - instrumentRelease);
          
          // Connect and start the harmonic
          harmonicOsc.connect(harmonicGain);
          harmonicGain.connect(audioContext.destination);
          harmonicOsc.start(startTime);
          harmonicOsc.stop(startTime + duration);
        }
      });
    }
  }


  function playPhrase(phrase) {
    // Don't play sounds if muted
    if (isMuted) return;
    
    // Initialize audio context if it doesn't exist yet
    initAudioContext();
    
    const now = audioContext.currentTime;
    const noteDuration = 0.4; // Slightly longer notes
    const gap = 0.1;
    let time = now;
    const gainValue = 0.06; // Reduced gain for softer sound

    // ADSR Envelope parameters (Attack, Decay, Sustain Level, Release)
    const attack = 0.05;
    const decay = 0.1;
    const sustainLevel = 0.6; //Sustain level as a fraction of the peak gain
    const release = 0.2;

    phrase.forEach(frequency => {
      playNote(frequency, time, noteDuration, gainValue, attack, decay, sustainLevel, release);
      time += noteDuration + gap;
    });
  }


  function createPetal(index, isRainbow = false) {
    const petal = document.createElement('div');
    petal.classList.add('petal');
    petal.style.transform = `rotate(${index * (360 / petalCount)}deg)`;
    petal.dataset.index = index;

    if (isRainbow) {
      petal.style.background = rainbowColors[index % rainbowColors.length];
    } else {
      petal.style.setProperty('--petal-color-start', petalColorOptions[currentColorIndex].start);
      petal.style.setProperty('--petal-color-end', petalColorOptions[currentColorIndex].end);
    }

    flowerContainer.appendChild(petal);
    return petal; // Return the petal
  }


  function animatePetalFall(petal) {
    const randomX = Math.random() * 200 - 100;
    const randomRotation = Math.random() * 360;
    const fallDuration = Math.random() * 1 + 1;
    
    // Create a trail effect for the falling petal
    const trail = setInterval(() => {
      // Get current position of the petal
      const rect = petal.getBoundingClientRect();
      if (rect.top < window.innerHeight) { // Only create trail if petal is still visible
        // Create a small particle at the petal's current position
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = '5px';
        particle.style.height = '5px';
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = getComputedStyle(petal).getPropertyValue('--petal-color-start');
        particle.style.left = `${rect.left + rect.width/2}px`;
        particle.style.top = `${rect.top + rect.height/2}px`;
        particle.style.opacity = '0.7';
        particle.style.zIndex = '90';
        particle.style.pointerEvents = 'none';
        
        document.body.appendChild(particle);
        
        // Animate and remove the trail particle
        gsap.to(particle, {
          opacity: 0,
          scale: 0.5,
          duration: 0.8,
          onComplete: () => particle.remove()
        });
      }
    }, 100); // Create a trail particle every 100ms

    // Play a random phrase from the melodicPhrases array
    const randomIndex = Math.floor(Math.random() * melodicPhrases.length);
    playPhrase(melodicPhrases[randomIndex]);

    gsap.to(petal, {
      y: 200,
      x: randomX,
      rotation: randomRotation,
      opacity: 0,
      duration: fallDuration,
      ease: "power2.inOut",
      onComplete: () => {
        clearInterval(trail); // Stop creating trail particles
        petal.remove();
        createFallingFlowerEmoji(); // Create emoji after petal falls
        
        // Create a burst effect at the petal's last position
        const burstX = parseInt(petal.style.transform.split('translateX(')[1]) || 0;
        const burstY = parseInt(petal.style.transform.split('translateY(')[1]) || 200;
        createSparkles(window.innerWidth/2 + burstX, window.innerHeight/2 + burstY/2);
      }
    });
  }

    function createFallingFlowerEmoji() {
        const emojis = ['ðŸŒ¸', 'ðŸŒ¼', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ·', 'ðŸŒ¹', 'âœ¨', 'ðŸ’®'];
        const emoji = document.createElement('div');
        emoji.classList.add('falling-flower');
        emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];

        // Position the emoji randomly at the top of the screen
        emoji.style.left = `${Math.random() * 100}vw`;
        emoji.style.top = '0'; // Start at the top
        
        // Random size for variety
        const size = Math.random() * 1.5 + 1.5; // Between 1.5 and 3em
        emoji.style.fontSize = `${size}em`;
        
        // Random color tinting
        const hue = Math.floor(Math.random() * 360);
        emoji.style.filter = `drop-shadow(0 0 10px rgba(255, 255, 255, 0.7)) hue-rotate(${hue}deg)`;
        
        document.body.appendChild(emoji);

        // Create a few sparkling particles around the emoji
        if (Math.random() > 0.5) {
            setTimeout(() => {
                createSparkles(parseInt(emoji.style.left), parseInt(emoji.offsetTop) + 50);
            }, Math.random() * 1000 + 500);
        }

        // Remove the emoji after the animation completes
        emoji.addEventListener('animationend', () => {
            emoji.remove();
        });
    }
    
    function createSparkles(x, y) {
        const sparkleCount = Math.floor(Math.random() * 5) + 3;
        for (let i = 0; i < sparkleCount; i++) {
            const sparkle = document.createElement('div');
            sparkle.textContent = 'âœ¨';
            sparkle.style.position = 'absolute';
            sparkle.style.left = `${x + (Math.random() * 40) - 20}px`;
            sparkle.style.top = `${y + (Math.random() * 40) - 20}px`;
            sparkle.style.fontSize = '0.8em';
            sparkle.style.opacity = '0';
            sparkle.style.zIndex = '100';
            sparkle.style.pointerEvents = 'none';
            
            document.body.appendChild(sparkle);
            
            // Create little burst animation with GSAP
            gsap.to(sparkle, {
                opacity: 1,
                duration: 0.2,
                onComplete: () => {
                    gsap.to(sparkle, {
                        opacity: 0,
                        duration: 0.5,
                        delay: 0.3,
                        scale: 0.5,
                        onComplete: () => {
                            sparkle.remove();
                        }
                    });
                }
            });
        }
    }

  function setBackgroundColor() {
    // Set the new background color with a smooth transition
    const newColor = backgroundColors[currentColorIndex];
    
    // Create a radial gradient for a more dynamic and magical background
    body.style.background = `radial-gradient(ellipse at center, ${newColor} 0%, ${adjustColor(newColor, -30)} 100%)`;
    
    // Update the color index for next time
    currentColorIndex = (currentColorIndex + 1) % backgroundColors.length;
  }
  
  // Helper function to darken or lighten a color
  function adjustColor(color, amount) {
    // Parse the hex color to RGB
    const hex = color.replace('#', '');
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);
    
    // Adjust the color
    r = Math.max(0, Math.min(255, r + amount));
    g = Math.max(0, Math.min(255, g + amount));
    b = Math.max(0, Math.min(255, b + amount));
    
    // Convert back to hex
    return `#${(r.toString(16).padStart(2, '0'))}${(g.toString(16).padStart(2, '0'))}${(b.toString(16).padStart(2, '0'))}`;
  }

  // Function to play all instruments at once (for rainbow flowers)
  function playRainbowChord() {
    if (isMuted || !audioContext) return;
    
    // Store the original instrument
    const originalInstrument = currentInstrument;
    
    // Create a fancy toast for rainbow flower
    const rainbowToast = document.createElement('div');
    rainbowToast.textContent = 'ðŸŒˆ RAINBOW FLOWER ORCHESTRA! ðŸŽµ';
    rainbowToast.style.position = 'absolute';
    rainbowToast.style.top = '50%';
    rainbowToast.style.left = '50%';
    rainbowToast.style.transform = 'translate(-50%, -50%)';
    rainbowToast.style.background = 'linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)';
    rainbowToast.style.color = 'white';
    rainbowToast.style.padding = '15px 25px';
    rainbowToast.style.borderRadius = '20px';
    rainbowToast.style.fontSize = '18px';
    rainbowToast.style.fontWeight = 'bold';
    rainbowToast.style.opacity = '0';
    rainbowToast.style.transition = 'opacity 0.5s ease';
    rainbowToast.style.zIndex = '2000';
    rainbowToast.style.textShadow = '0 0 5px black';
    rainbowToast.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.7)';
    
    document.body.appendChild(rainbowToast);
    
    // Fade in, then fade out
    setTimeout(() => {
      rainbowToast.style.opacity = '1';
      setTimeout(() => {
        rainbowToast.style.opacity = '0';
        setTimeout(() => {
          rainbowToast.remove();
        }, 1000);
      }, 3000);
    }, 100);
    
    // Get the current time from the audio context
    const now = audioContext.currentTime;
    
    // Notes for a C major chord in different octaves
    const notes = [c4, e4, g4, c5];
    
    // Time spacing between instrument entries
    const entryDelay = 0.2;
    
    // Total chord duration
    const chordDuration = 2.5;
    
    // Play each instrument with a staggered entry
    instruments.forEach((instrument, i) => {
      // Set the current instrument temporarily
      currentInstrument = i;
      
      // Play notes with this instrument with a staggered entry
      notes.forEach((note, j) => {
        // Delay each instrument's entry
        const startTime = now + (i * entryDelay);
        
        // Adjust volume based on number of instruments
        const adjustedVolume = 0.03 / Math.sqrt(instruments.length);
        
        // Create random sparkles for each note
        setTimeout(() => {
          createSparkles(
            window.innerWidth * Math.random(), 
            window.innerHeight * Math.random()
          );
        }, i * entryDelay * 1000 + j * 100);
        
        // Play the note
        playNote(
          note,                  // frequency
          startTime,             // start time
          chordDuration,         // duration
          adjustedVolume,        // volume (adjusted down for many instruments)
          0.05,                  // attack
          0.1,                   // decay
          0.6,                   // sustain
          0.8                    // release
        );
      });
    });
    
    // Return to the original instrument
    currentInstrument = originalInstrument;
  }

  function resetFlower() {
    // Clear existing petals efficiently
    petals.forEach(petal => petal.remove());
    petals = [];

    petalCount = Math.floor(Math.random() * 10) + 5;
    currentColorIndex = Math.floor(Math.random() * petalColorOptions.length);
    setBackgroundColor();
    
    // Change to a new instrument for this flower
    currentInstrument = (currentInstrument + 1) % instruments.length;
    
    // Generate a rainbow flower randomly
    let isRainbowFlower = Math.random() < rainbowFlowerChance;
    
    // Create new petals and store them in the petals array
    for (let i = 0; i < petalCount; i++) {
      const petal = createPetal(i, isRainbowFlower);
      petals.push(petal);
    }

    // Remove the 'no-petals' class
    flowerContainer.classList.remove('no-petals');
    
    // Initialize audio context if needed
    if (!isMuted) {
      initAudioContext();
    }
    
    // For rainbow flowers, play all instruments at once!
    if (isRainbowFlower && !isMuted) {
      playRainbowChord();
    } 
    // For regular flowers, show the instrument name and play a chord
    else if (!isMuted) {
      // Display the current instrument name
      const instrumentName = instruments[currentInstrument].name;
      const instrumentToast = document.createElement('div');
      instrumentToast.textContent = `ðŸŽµ ${instrumentName}`;
      instrumentToast.style.position = 'absolute';
      instrumentToast.style.bottom = '20px';
      instrumentToast.style.left = '50%';
      instrumentToast.style.transform = 'translateX(-50%)';
      instrumentToast.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      instrumentToast.style.color = 'white';
      instrumentToast.style.padding = '8px 15px';
      instrumentToast.style.borderRadius = '20px';
      instrumentToast.style.fontSize = '14px';
      instrumentToast.style.opacity = '0';
      instrumentToast.style.transition = 'opacity 0.3s ease';
      instrumentToast.style.zIndex = '1000';
      
      document.body.appendChild(instrumentToast);
      
      // Fade in, then fade out
      setTimeout(() => {
        instrumentToast.style.opacity = '1';
        setTimeout(() => {
          instrumentToast.style.opacity = '0';
          setTimeout(() => {
            instrumentToast.remove();
          }, 500);
        }, 2000);
      }, 100);
      
      // Play a chord with the new instrument to introduce it
      const now = audioContext.currentTime;
      [c4, e4, g4].forEach((note, index) => {
        playNote(note, now, 1.5, 0.04, 0.05, 0.1, 0.6, 0.5);
      });
    }
  }


  function handleFlowerClick() {
    // Initialize audio context on first interaction
    initAudioContext();
    
    if (petals.length > 0) {
      const randomIndex = Math.floor(Math.random() * petals.length);
      const petalToFall = petals[randomIndex];
      animatePetalFall(petalToFall);
      petals.splice(randomIndex, 1); // Remove petal from array


      if (petals.length === 0) {
        flowerContainer.classList.add('no-petals'); // Add class when no petals
      }
    } else {
      resetFlower();
    }
  }


  flowerContainer.addEventListener('click', handleFlowerClick);
  
  // Mute button functionality
  function toggleMute() {
    isMuted = !isMuted;
    
    // Update button text based on mute state
    muteButton.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
    
    // Add visual indicator of mute state
    if (isMuted) {
      muteButton.style.borderColor = '#888';
      muteButton.style.color = '#888';
    } else {
      muteButton.style.borderColor = '#FF69B4';
      muteButton.style.color = '#000';
      
      // Initialize and resume audio context if unmuting
      initAudioContext();
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      // Show the current instrument when unmuting
      const instrumentName = instruments[currentInstrument].name;
      const instrumentToast = document.createElement('div');
      instrumentToast.textContent = `ðŸŽµ Current: ${instrumentName}`;
      instrumentToast.style.position = 'absolute';
      instrumentToast.style.bottom = '20px';
      instrumentToast.style.left = '50%';
      instrumentToast.style.transform = 'translateX(-50%)';
      instrumentToast.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      instrumentToast.style.color = 'white';
      instrumentToast.style.padding = '8px 15px';
      instrumentToast.style.borderRadius = '20px';
      instrumentToast.style.fontSize = '14px';
      instrumentToast.style.opacity = '0';
      instrumentToast.style.transition = 'opacity 0.3s ease';
      instrumentToast.style.zIndex = '1000';
      
      document.body.appendChild(instrumentToast);
      
      // Fade in, then fade out
      setTimeout(() => {
        instrumentToast.style.opacity = '1';
        setTimeout(() => {
          instrumentToast.style.opacity = '0';
          setTimeout(() => {
            instrumentToast.remove();
          }, 500);
        }, 2000);
      }, 100);
    }
    
    // Play a quick sound feedback when unmuting (but not when initially muting)
    if (!isMuted && audioContext) {
      const now = audioContext.currentTime;
      playNote(c4, now, 0.1, 0.03, 0.01, 0.05, 0.5, 0.05);
    }
  }
  
  muteButton.addEventListener('click', toggleMute);

  // Create background stars
  createStars();
  
  // Initial flower creation
  resetFlower();
  
  // Add a welcome sound on page load (will only play after first interaction due to browser policies)
  window.addEventListener('click', function initialClick() {
    if (!isMuted) {
      initAudioContext();
      if (audioContext) {
        // Just for fun, force a rainbow flower orchestra on first load
        playRainbowChord();
      }
    }
    
    // Add some initial sparkle effects
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        createSparkles(Math.random() * window.innerWidth, Math.random() * window.innerHeight);
      }, i * 200);
    }
    
    // Create a few falling flowers for visual impact
    for (let i = 0; i < 8; i++) {
      setTimeout(() => {
        createFallingFlowerEmoji();
      }, i * 150);
    }
    
    // Welcome message
    setTimeout(() => {
      const welcomeMsg = document.createElement('div');
      welcomeMsg.textContent = 'âœ¨ Click the flower to play! âœ¨';
      welcomeMsg.style.position = 'absolute';
      welcomeMsg.style.bottom = '40px';
      welcomeMsg.style.left = '50%';
      welcomeMsg.style.transform = 'translateX(-50%)';
      welcomeMsg.style.background = 'rgba(0, 0, 0, 0.7)';
      welcomeMsg.style.color = 'white';
      welcomeMsg.style.padding = '10px 20px';
      welcomeMsg.style.borderRadius = '20px';
      welcomeMsg.style.fontSize = '16px';
      welcomeMsg.style.opacity = '0';
      welcomeMsg.style.transition = 'opacity 0.5s ease';
      welcomeMsg.style.zIndex = '2000';
      
      document.body.appendChild(welcomeMsg);
      
      // Fade in, then fade out
      setTimeout(() => {
        welcomeMsg.style.opacity = '1';
        setTimeout(() => {
          welcomeMsg.style.opacity = '0';
          setTimeout(() => {
            welcomeMsg.remove();
          }, 1000);
        }, 3000);
      }, 500);
    }, 1000);
    
    // Remove the event listener after first click
    window.removeEventListener('click', initialClick);
  }, {once: true});
</script>

</body>
</html>
